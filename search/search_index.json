{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my tutorial repository.","title":"Welcome"},{"location":"circuits/attiny85/","text":"About the ATtiny85 Microcontroller The ATtiny85 microcontroller is a powerful yet extremely low cost (~ 50\u00a2 each) integrated circuit . The chip itself operates with an 8-bit data bus, which means it can access 8-bits of data per computer instruction (set, copy, add, subtract, multiply, compare, etc.). Its CPU speed is capable of up to 8MHz and it has 8KB flash memory for storing Arduino programs. [By comparison, our Adafruit Feather M0 microcontrollers have a 32-bit data bus and operate at 48MHz with 256KB flash memory. Much more powerful, but they cost 7 times as much!] The ATtiny85 requires an operating voltage between 1.8V and 5.5V and has 5 I/O (input/output) pins for connecting electronic components. Here is the pin breakout: Pin #8 (VCC) is connected to the positive terminal of your voltage source (1.8V - 5.5V). Pin #4 (GND) is connected to ground / the negative terminal of your voltage source. The Arduino programming language can be used to control pins #5, #6, #7, #2 and #3: Pins 0 - 4 (marked in light blue) are all capable of digitalWrite()/digitalRead() functions Pins 0 1 are capable of PWM analogWrite() at 8-bit resolution (0-255) Pins A1-A3 (marked in red) are capable of analogRead(), measuring analog voltage through a 10-bit ADC (Analog to Digital Converter). 1 The RESET pin is a special pin; connecting this pin to GND will restart the program running on your ATtiny85. ATtiny85 Hands-On with Tinkercad Over the course of this tutorial, we will create several circuits with the ATtiny85 microcontroller using Autodesk's Tinkercad circuit simulator: The classic project \"Blinky\" Programmatically Fade an LED Programmatically Fade an LED with a Potentiometer RGB LED color control with a Potentiometer First, however, we need to wire up our ATtiny85 to a power supply. Powering an ATtiny85 Warning As noted in the \"About\" section above, the ATtiny85 has an operating voltage between 1.8V and 5.5V. Anything below 1.8V and the microcontroller will not have enough voltage to function. Anything over 5.5V and you risk overloading the chip, as illustrated by the 9V battery blowing the IC in the image below: For this tutorial, you can use 1.5V AA batteries -- you'll need more than one (2 batteries = 3V; 3 batteries = 4.5V) -- or a 3V coin cell battery. The illustrations for the remainder of this tutorial will make use of a 3V coin cell battery. Go to tinkercad.com and sign into your account. Go to your Tinkercad Dashboard: https://www.tinkercad.com/#/dashboard Click on the Circuits button in the left panel. Click on the green \"Create new Circuit\" button. Create new Circuit A new blank canvas will open in your browser. Place your ATtiny85 in the center of your breadboard, straddling the breadboard's ravine. Place a battery near your breadboard. Use a red wire to connect the positive (+) terminal of the battery to the + power bus of the breadboard. Use a red wire to connect the + power bus of the breadboard to the VCC pin of the ATtiny85. Use a black wire to connect the negative (-) terminal of the battery to the - power bus of the breadboard. Use a black wired to connect the - power bus the breadboard to the GND pin of the ATtiny85. Project \"Blinky\" First let's wire up the ATtiny85 for the classic Arduino project, Project Blinky. Here is a schematic: For this project, you will need the following additional components: 1 x Red LED 1 x 47\u03a9 Resistor Drag the two components into your Tinkercad window and, consulting the circuit schematic above, recreate the circuit on your breadboard. Connect the anode (positive terminal) of the LED to digital pin 0 (light blue) of the ATtiny85 microcontroller. Connect the cathode (negative terminal) of the LED to one end of the resistor. Connect the other end of the resistor to GND / the negative (-) power bus rail. Your final wiring should look like this: Next we'll turn to the code necessary to turn the LED on and off programmatically. Click on the Code button in the upper-right of the interface. By default, Tinkercad will open into the Blocks code interface. Blocks is a visual coding paradigm based on MIT's Scratch . Note that Tinkercad has already pre-populated the Blocks code interface with blocks that set the ATtiny85's \"built-in\" LED to HIGH, wait one second, and then set the ATtiny85's \"built-in\" LED to LOW, waiting another second. This may be confusing, since the ATtiny85 does NOT have a \"built-in\" LED like other Arduino microcontrollers such as the Arduino Uno do. We could replace the blocks that reference the built-in LED with the block that would \"Set Pin 0 to HIGH/LOW\". However, we're going to switch over to the Text coding view instead. Find the dropdown in the upper-left of the code panel and change it from \"Blocks\" to \"Text\". You will be prompted to confirm this intention. Click \"Continue.\" You will note that Tinkercad has pre-populated the code interface with the following: void setup () { pinMode ( 0 , OUTPUT ); } void loop () { digitalWrite ( 0 , HIGH ); delay ( 1000 ); // Wait for 1000 millisecond(s) digitalWrite ( 0 , LOW ); delay ( 1000 ); // Wait for 1000 millisecond(s) } As it happens, this is just the code we need to turn pin 0 of the ATtiny85 on and off every second. In the setup() function, the pinMode of pin 0 is set to OUTPUT . And then in the loop() function, the digitalWrite() function is called on pin 0 and set to HIGH. A delay() function of 1000 milliseconds is called. And then a second digitalWrite() function sets pin 0 to LOW, followed by one more 1000 millisecond delay. Click \"Start Simulation\" and your LED should blink on and off. Congratulations! You've completed Project Blinky! Programmatically Fade an LED We can use this same wiring scheme to fade an LED instead of blinking it. Instead of the digitalWrite() function, we'll instead use analogWrite() , taking advantage of the fact that Pin 0 is one of two pins on the ATtiny85 (marked in green below) that is capable of PWM (pulse width modulation). Let's modify the code accordingly: The setup() function can be left alone; we want digital pin 0 to function as an OUTPUT . The loop() function requires significant modification, so delete its contents entirely and we will work through the required logic line by line. Recall that PWM works by modifying the duty cycle of the pin. Rather than being HIGH 100% of the time with a digitalWrite(pin, HIGH) function, or LOW 100% of the time with a digitalWrite(pin, LOW) function, the analogWrite() function enables us to set different percentages of HIGH/LOW to approximate an analog voltage signal at 256 levels between 0V (LOW) and 3V (HIGH). So, analogWrite(0, 127) will cycle the LED HIGH 50% of the time and LOW 50% of the time and in the case of our 3V circuit, will approximate sending an analog voltage of 1.5V through the LED. So, to fade our LED, we will want to iterate through increasing values between 0 and 255 to fade the LED to on, and then iterate through decreasing values from 255 to 0 to fade the LED off. One way to write that code is line by line: void loop (){ analogWrite ( 0 , 0 ); delay ( 30 ); analogWrite ( 0 , 5 ); delay ( 30 ); analogWrite ( 0 , 15 ); delay ( 30 ); analogWrite ( 0 , 20 ); delay ( 30 ); analogWrite ( 0 , 25 ); delay ( 30 ); analogWrite ( 0 , 30 ); delay ( 30 ); ... // continue increasing analogWrite by 5 analogWrite ( 0 , 250 ); delay ( 30 ); analogWrite ( 0 , 255 ); delay ( 30 ); analogWrite ( 0 , 250 ); delay ( 30 ); analogWrite ( 0 , 245 ); delay ( 30 ); analogWrite ( 0 , 240 ); delay ( 30 ); analogWrite ( 0 , 235 ); delay ( 30 ); ... // continue decreasing analogWrite by 5 analogWrite ( 0 , 15 ); delay ( 30 ); analogWrite ( 0 , 10 ); delay ( 30 ); analogWrite ( 0 , 5 ); } But that is NOT very efficient! Luckily, like many programming languages, Arduino has a for control structure that will allow us to radically economize on the lines of code necessary to achieve the same result. Here is the basic structure of a for loop: for ( initialization ; condition ; increment ) { //statement(s); } By convention, most programmers use the variable name i within a for loop. For example: for ( int i = 0 ; i lt ; 1000 ; i = i + 1 ) { // this code will run 1000 times! } But one can use any variable name: for ( int elephants = 0 ; elephants lt ; 1000 ; elephants = elephants + 1 ) { // this code will also run 1000 times! } The incrementing code, i = i + 1 is often abbreviated as i++ : for ( int i = 0 ; i lt ; 1000 ; i ++ ) { // this code will run 1000 times, too! } Finally, incrementation is not limited to increments of 1: // increments of 2 for ( int i = 0 ; i lt ; 1000 ; i = i + 2 ) { // this code will run 500 times } // increments of 5, abbreviated notation for ( int i = 0 ; i lt ; 1000 ; i += 5 ) { // this code will run 200 times! } Whew! That was quite a detour. Let's get back to our LED fade loop() function. We want our analogWrite() function to iterate up from 0 to 255 in increments of 5, so within our loop() function we can write: void loop () { for ( int lightLevel = 0 ; lightLevel lt ; = 255 ; lightLevel = lightLevel + 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } } Click \"Start Simulation\" and you'll see that we're halfway there. The LED starts OFF, fades to ON, and then jumps back to OFF again, fades to ON, jumps back to OFF, etc, etc. So we need a second for loop to decrement the light level (highlighted in yellow): void loop () { for ( int lightLevel = 0 ; lightLevel lt ; = 255 ; lightLevel = lightLevel + 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } for ( int lightLevel = 255 ; lightLevel gt ; = 0 ; lightLevel = lightLevel - 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } } Click \"Start Simulation\" and the LED should slowly fade in and out, as if it were breathing. Congratulations! You've successfully completed the \"Programmatically Fade an LED\" project! Programmatically Fade an LED with a Potentiometer In this next project, we'll add a potentiometer to our circuit and use it to control the fade level of the LED. Here is the circuit schematic for your reference: First, delete all of the code in the Text interface of your Code panel. We will write new code for this project. Next, close the Code panel to access your Components bin and locate the Potentiometer . Drag it onto your Tinkercad canvas. Connect the outer terminals of the potentiometer to the positive (+) and negative (-) bus of your breadboard. The \"wiper\" terminal of the potentiometer should be connected to one of the three pins on the ATtiny85 that are capable of reading analog voltages. They are marked in red as pins A1, A2, and A3 on the pinout diagram. In the example below, we've connected the potentiometer's wiper to pin A3 of the ATtiny85 using a yellow wire. Note At this point you may be asking: Why didn't we connect the potentiometer wiper in series with the LED to directly control the LED's brightness? That's a great question! Indeed, you might even be wondering why we need the ATtiny85 to accomplish this project at all! In fact, if all we want to do is use a potentiometer to control the brightness of an LED, we don't need a microcontroller to do that! You could save yourself time and money and avoid having to touch code at all! The purpose of this project, however, is on the one hand purely pedagogical: to teach you how to use a microcontroller to read an analog voltage. A microcontroller can put that information to use in many different ways. In the last project of this tutorial we'll make use of that analog signal to create a circuit that would be quite a bit more difficult to accomplish without a microcontroller. Stay tuned! Now that we've wired up our potentiometer, let's turn to the Arduino code necessary to read its output. Open the Code panel and again, switch to the Text interface. Let's begin by initializing some variables. We need one to hold the value coming in from our potentiometer on pin A3: int pot_value = 0 ; And let's use a variable name to identify the pin that attaches to our LED. This is considered a good practice in case you ever need to modify the pin configuration on your hardware. Rather than having to hunt through your code for every reference to pin 0 , you can simply change it in the variable list at the top of your sketch. int pot_value = 0 ; int ledPin = 0 ; Let's do the same for the pin that attaches to our potentiometer: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; Now that we've declared our variables, we can use these in our setup() function to set these pins as OUTPUT and INPUT as needed: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; void setup () { pinMode ( ledPin , OUTPUT ); pinMode ( sensorPin , INPUT ); } We can now turn our attention to our program's loop() function. The first thing we want to do each program cycle is read the value coming in over the ADC at pin A3 from the potentiometer and assign it to our pot_value variable: void loop () { pot_value = analogRead ( sensorPin ); } The next thing we want to do is to use that value to set the analogWrite() value for the LED pin. Important! The ADC of pin A3 runs at 10 bits, which means that analogRead() is going to be giving readings between 0 and 1023. Our analogWrite() function can only take an 8 bit value, between 0 and 255. To reconcile this difference, we need to use Arduino's map() math function and then use that re-mapped value to drive our LED. In the code highlighted below, we first re-map the 10 bit pot_value to an 8 bit number and then pass that re-mapped value to analogWrite() . void loop () { pot_value = analogRead ( sensorPin ); pot_value = map ( pot_value , 0 , 1023 , 0 , 255 ); analogWrite ( ledPin , pot_value ); } Our full code should read as follows: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; void setup () { pinMode ( ledPin , OUTPUT ); pinMode ( sensorPin , INPUT ); } void loop () { pot_value = analogRead ( sensorPin ); pot_value = map ( pot_value , 0 , 1023 , 0 , 255 ); analogWrite ( ledPin , pot_value ); } Click on \"Start Simulation.\" Use your mouse to manipulate the potentiometer. When the indicator is closest to the pin you have connected to the positive (+) voltage, the LED should burn brightest. When the indicator is moved toward the pin that you have connected to ground (-), the LED should dim and then turn off completely. Congratulations! You've completed the \"Programmatically Fade an LED with a Potentiometer\" project. Challenge You can use this same hardware setup to build another classic Arduino project: Using a potentiometer to control the blink speed of an LED. All you need to change is the Arduino code. See if you can't figure out how to make it work on your own, using the digitalWrite() , delay() , and map() functions. Hint: Map the potentiometer values to milliseconds and use in the delay() function! Email your code to your professor! RGB LED Color Control with a Potentiometer For our final circuit in this tutorial, we'll introduce a new component - an RGB LED - and use the readings from a potentiometer to programmatically change its colors depending on where the potentiometer is positioned. To save time, we'll begin by duplicating the project we just completed above. Return to your Circuits Dashboard . Find the design you just completed and click on the cog in the upper right corner of the project's card, as illustrated below. From the drop-down that appears, choose \"Duplicate.\" Tinkercad should take you to a new project, automatically entitled \"Copy of [original project name]\". For this circuit, we'll use the following circuit diagram: Note Note that the ATtiny85 in its basic configuration only has two PWM pins, and to use the full range of an RGB LED you need to have three. While it is possible to circumvent this limitation with code to enable a 3rd PWM pin, the Tinkercad simulator is not capable of that degree of complexity. So for the purposes of this tutorial, we'll simply make by using the ATtiny85's two PWM pins (0 and 1) and then pin 2 as a digital pin to generate a more limited set of colors. Let's begin with the wiring of the RGB LED. Delete the red LED, its resistor, and all of its related jumper wires from your project. This should leave only the battery and the potentiometer wired to your ATtiny85. Locate in the Components bin the RGB LED component and drag it to your breadboard. Connect the \"common cathode\" (-) pin of the RGB LED to GND. Add three 47\u03a9 resistor to your canvas, connecting one each to the red, green, and blue pins of the RGB LED. Connect each resistor to a specific digital pin on the ATtiny85, as follows: Connect the blue pin's resistor to digital pin 1 . Connect the green pin's resistor to digital pin 0 . Connect the red pin's resistor to digital pin 2 . Your circuit should look something like this: Tip If the image above is confusing to you, remember how a breadboard works. Everything in a numbered row on one side of the ravine is connected together. Now we can turn our attention to the Arduino Code. An RGB LED works by mixing three different LEDs - one red, one green, one blue - in different ratios of intensity. Let's begin by declaring variables for each of our RGB LED's pins: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; And then let's initialize each of these pins as OUTPUTs in the setup() function: void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } Here is a table that outlines different color combinations for the Tinkercad simulator based on ratios of red, green, and blue: Color Red Green Blue Red 100% 0% 0% Green 0% 100% 0% Blue 0% 0% 100% Yellow 100% 100% 0% Orange 100% 25% 0% Purple 100% 0% 100% Magenta 100% 0% 30% Turquoise 0% 100% 100% The above values can be translated to code, using analogWrite() and converting the percentages to an 8-bit value. So the color orange can be achieved by the following: // orange = red 100%, green 20%, blue 0% analogWrite ( redPin , 255 ); analogWrite ( greenPin , 64 ); // 25% of 255 is approx. 64 analogWrite ( bluePin , 0 ); Since our redPin , pin 2 is not capable of PWM, we instead need to use digitalWrite() on that pin: // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); // 25% of 255 is approx. 64 analogWrite ( bluePin , 0 ); Put the code above in your loop() function and test it out. The full code is: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } void loop () { // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } The RGB LED should glow orange. One of the things you can do in Arduino is declare custom functions outside of your setup() and loop() functions and then call them in these main functions. For example, you could create a function below your loop() function for the color orange: void colorOrange (){ // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } Then you can call that function in your loop() : int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } void loop (){ colorOrange (); } void colorOrange () { // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } Go ahead and create additional custom functions for red, blue, green, yellow, and turquiose. Try to do this on your own, without consulting the code below. void colorRed () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 0 ); } void colorBlue () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 255 ); } void colorGreen () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 0 ); } void colorYellow () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 0 ); } void colorTurquoise () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 255 ); } void colorPurple () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 255 ); } Then create a simple sketch that cycles through the colors for a duration of two seconds each. Replace your loop() function with the following: void loop () { colorRed (); delay ( 2000 ); colorBlue (); delay ( 2000 ); colorGreen (); delay ( 2000 ); colorYellow (); delay ( 2000 ); colorPurple (); delay ( 2000 ); colorTurquoise (); delay ( 2000 ); } Test out your code by clicking the \"Start Simulation\" button. Failure? If you used a different sequence of colors than the sequence above, you may have noticed that the simulator skips one or more of your colors. This is an error in the simulator, not your code. I have found that the simulator struggles to switch to orange in particular. Finally, we can now integrate the potentiometer back into our code and use it to select different colors. Note that the potentiometer has seven (7) dots around its perimeter, which have been marked with letters a-g in the image below left. These markings roughly correspond to the 10-bit potentiometer readings in the table at right: Marking pot_value color a 1023 red b 850 blue c 680 green d 510 yellow e 340 purple f 170 turquoise g 0 orange Since it is unlikely that anyone can consistently set the potentiometer to the exact position that generates those specific values, we can create a buffer of a range of values to segment our potentiometer into seven \"zones\": Marking ideal pot_value range color a 1023 940 - 1023 red b 850 770 - 940 blue c 680 599 - 769 green d 510 428 - 598 yellow e 340 257 - 427 purple f 170 86 - 256 turquoise g 0 0 - 85 orange Alternatively, and perhaps more straightforward, we can map the potentiometer values to a smaller range of values and then use the following to demarcate the potentiometer: Marking ideal pot_value range color a 18 17 - 18 red b 15 14 - 16 blue c 12 11 - 13 green d 9 8 - 10 yellow e 6 5 - 7 purple f 3 2 - 4 turquoise g 0 0 - 1 orange Let's make use of this information to control the RGB LED color with the potentiometer. Return to your project's code in the Code panel. Add the highlighted variables -- they should be familiar to you -- above your setup() function: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; int sensorPin = A3 ; int pot_value = 0 ; void setup () ... Add the highlighted line to your setup() function: void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); pinMode ( sensorPin , INPUT ); } Finally, re-write your loop() function in this way: At the start of each program loop, set the value of pot_value to the reading from the potentiometer: void loop () { pot_value = analogRead ( sensorPin ); } Next, let's re-map the potentiometer value to a new int variable named val : void loop () { pot_value = analogRead ( sensorPin ); int val = map ( pot_value , 0 , 1023 , 0 , 18 ); } Then use a series of if statements to set the RGB LED to different colors based on the value of val depending on whether it falls within a specified range of values, as in the code below: void loop () { pot_value = analogRead ( sensorPin ); int val = map ( pot_value , 0 , 1023 , 0 , 18 ); if ( 0 lt ; = val amp ; amp ; val lt ; = 1 ) { colorOrange (); } if ( 2 lt ; = val amp ; amp ; val lt ; = 4 ) { colorTurquoise (); } if ( 5 lt ; = val amp ; amp ; val lt ; = 7 ) { colorPurple (); } if ( 8 lt ; = val amp ; amp ; val lt ; = 10 ) { colorYellow (); } if ( 11 lt ; = val amp ; amp ; val lt ; = 13 ) { colorGreen (); } if ( 14 lt ; = val amp ; amp ; val lt ; = 16 ) { colorBlue (); } if ( 17 lt ; = val amp ; amp ; val lt ; = 18 ) { colorRed (); } } Test your project by clicking \"Start Simulation\" and then click on the potentiometer to move it between different marks. Great job completing the last project in this tutorial! Begin brainstorming a circuit based on the ATtiny85 that you'd like to prototype and have manufactured... \"10-bit\" refers to the resolution of the ADC, meaning that it can convert an analog signal into 1024 (0-1023) discrete levels. See https://en.wikipedia.org/wiki/Analog-to-digital_converter#Resolution","title":"ATtiny85"},{"location":"circuits/attiny85/#about-the-attiny85-microcontroller","text":"The ATtiny85 microcontroller is a powerful yet extremely low cost (~ 50\u00a2 each) integrated circuit . The chip itself operates with an 8-bit data bus, which means it can access 8-bits of data per computer instruction (set, copy, add, subtract, multiply, compare, etc.). Its CPU speed is capable of up to 8MHz and it has 8KB flash memory for storing Arduino programs. [By comparison, our Adafruit Feather M0 microcontrollers have a 32-bit data bus and operate at 48MHz with 256KB flash memory. Much more powerful, but they cost 7 times as much!] The ATtiny85 requires an operating voltage between 1.8V and 5.5V and has 5 I/O (input/output) pins for connecting electronic components. Here is the pin breakout: Pin #8 (VCC) is connected to the positive terminal of your voltage source (1.8V - 5.5V). Pin #4 (GND) is connected to ground / the negative terminal of your voltage source. The Arduino programming language can be used to control pins #5, #6, #7, #2 and #3: Pins 0 - 4 (marked in light blue) are all capable of digitalWrite()/digitalRead() functions Pins 0 1 are capable of PWM analogWrite() at 8-bit resolution (0-255) Pins A1-A3 (marked in red) are capable of analogRead(), measuring analog voltage through a 10-bit ADC (Analog to Digital Converter). 1 The RESET pin is a special pin; connecting this pin to GND will restart the program running on your ATtiny85.","title":"About the ATtiny85 Microcontroller"},{"location":"circuits/attiny85/#attiny85-hands-on-with-tinkercad","text":"Over the course of this tutorial, we will create several circuits with the ATtiny85 microcontroller using Autodesk's Tinkercad circuit simulator: The classic project \"Blinky\" Programmatically Fade an LED Programmatically Fade an LED with a Potentiometer RGB LED color control with a Potentiometer First, however, we need to wire up our ATtiny85 to a power supply.","title":"ATtiny85 Hands-On with Tinkercad"},{"location":"circuits/attiny85/#powering-an-attiny85","text":"Warning As noted in the \"About\" section above, the ATtiny85 has an operating voltage between 1.8V and 5.5V. Anything below 1.8V and the microcontroller will not have enough voltage to function. Anything over 5.5V and you risk overloading the chip, as illustrated by the 9V battery blowing the IC in the image below: For this tutorial, you can use 1.5V AA batteries -- you'll need more than one (2 batteries = 3V; 3 batteries = 4.5V) -- or a 3V coin cell battery. The illustrations for the remainder of this tutorial will make use of a 3V coin cell battery. Go to tinkercad.com and sign into your account. Go to your Tinkercad Dashboard: https://www.tinkercad.com/#/dashboard Click on the Circuits button in the left panel. Click on the green \"Create new Circuit\" button. Create new Circuit A new blank canvas will open in your browser. Place your ATtiny85 in the center of your breadboard, straddling the breadboard's ravine. Place a battery near your breadboard. Use a red wire to connect the positive (+) terminal of the battery to the + power bus of the breadboard. Use a red wire to connect the + power bus of the breadboard to the VCC pin of the ATtiny85. Use a black wire to connect the negative (-) terminal of the battery to the - power bus of the breadboard. Use a black wired to connect the - power bus the breadboard to the GND pin of the ATtiny85.","title":"Powering an ATtiny85"},{"location":"circuits/attiny85/#project-blinky","text":"First let's wire up the ATtiny85 for the classic Arduino project, Project Blinky. Here is a schematic: For this project, you will need the following additional components: 1 x Red LED 1 x 47\u03a9 Resistor Drag the two components into your Tinkercad window and, consulting the circuit schematic above, recreate the circuit on your breadboard. Connect the anode (positive terminal) of the LED to digital pin 0 (light blue) of the ATtiny85 microcontroller. Connect the cathode (negative terminal) of the LED to one end of the resistor. Connect the other end of the resistor to GND / the negative (-) power bus rail. Your final wiring should look like this: Next we'll turn to the code necessary to turn the LED on and off programmatically. Click on the Code button in the upper-right of the interface. By default, Tinkercad will open into the Blocks code interface. Blocks is a visual coding paradigm based on MIT's Scratch . Note that Tinkercad has already pre-populated the Blocks code interface with blocks that set the ATtiny85's \"built-in\" LED to HIGH, wait one second, and then set the ATtiny85's \"built-in\" LED to LOW, waiting another second. This may be confusing, since the ATtiny85 does NOT have a \"built-in\" LED like other Arduino microcontrollers such as the Arduino Uno do. We could replace the blocks that reference the built-in LED with the block that would \"Set Pin 0 to HIGH/LOW\". However, we're going to switch over to the Text coding view instead. Find the dropdown in the upper-left of the code panel and change it from \"Blocks\" to \"Text\". You will be prompted to confirm this intention. Click \"Continue.\" You will note that Tinkercad has pre-populated the code interface with the following: void setup () { pinMode ( 0 , OUTPUT ); } void loop () { digitalWrite ( 0 , HIGH ); delay ( 1000 ); // Wait for 1000 millisecond(s) digitalWrite ( 0 , LOW ); delay ( 1000 ); // Wait for 1000 millisecond(s) } As it happens, this is just the code we need to turn pin 0 of the ATtiny85 on and off every second. In the setup() function, the pinMode of pin 0 is set to OUTPUT . And then in the loop() function, the digitalWrite() function is called on pin 0 and set to HIGH. A delay() function of 1000 milliseconds is called. And then a second digitalWrite() function sets pin 0 to LOW, followed by one more 1000 millisecond delay. Click \"Start Simulation\" and your LED should blink on and off. Congratulations! You've completed Project Blinky!","title":"Project \"Blinky\""},{"location":"circuits/attiny85/#programmatically-fade-an-led","text":"We can use this same wiring scheme to fade an LED instead of blinking it. Instead of the digitalWrite() function, we'll instead use analogWrite() , taking advantage of the fact that Pin 0 is one of two pins on the ATtiny85 (marked in green below) that is capable of PWM (pulse width modulation). Let's modify the code accordingly: The setup() function can be left alone; we want digital pin 0 to function as an OUTPUT . The loop() function requires significant modification, so delete its contents entirely and we will work through the required logic line by line. Recall that PWM works by modifying the duty cycle of the pin. Rather than being HIGH 100% of the time with a digitalWrite(pin, HIGH) function, or LOW 100% of the time with a digitalWrite(pin, LOW) function, the analogWrite() function enables us to set different percentages of HIGH/LOW to approximate an analog voltage signal at 256 levels between 0V (LOW) and 3V (HIGH). So, analogWrite(0, 127) will cycle the LED HIGH 50% of the time and LOW 50% of the time and in the case of our 3V circuit, will approximate sending an analog voltage of 1.5V through the LED. So, to fade our LED, we will want to iterate through increasing values between 0 and 255 to fade the LED to on, and then iterate through decreasing values from 255 to 0 to fade the LED off. One way to write that code is line by line: void loop (){ analogWrite ( 0 , 0 ); delay ( 30 ); analogWrite ( 0 , 5 ); delay ( 30 ); analogWrite ( 0 , 15 ); delay ( 30 ); analogWrite ( 0 , 20 ); delay ( 30 ); analogWrite ( 0 , 25 ); delay ( 30 ); analogWrite ( 0 , 30 ); delay ( 30 ); ... // continue increasing analogWrite by 5 analogWrite ( 0 , 250 ); delay ( 30 ); analogWrite ( 0 , 255 ); delay ( 30 ); analogWrite ( 0 , 250 ); delay ( 30 ); analogWrite ( 0 , 245 ); delay ( 30 ); analogWrite ( 0 , 240 ); delay ( 30 ); analogWrite ( 0 , 235 ); delay ( 30 ); ... // continue decreasing analogWrite by 5 analogWrite ( 0 , 15 ); delay ( 30 ); analogWrite ( 0 , 10 ); delay ( 30 ); analogWrite ( 0 , 5 ); } But that is NOT very efficient! Luckily, like many programming languages, Arduino has a for control structure that will allow us to radically economize on the lines of code necessary to achieve the same result. Here is the basic structure of a for loop: for ( initialization ; condition ; increment ) { //statement(s); } By convention, most programmers use the variable name i within a for loop. For example: for ( int i = 0 ; i lt ; 1000 ; i = i + 1 ) { // this code will run 1000 times! } But one can use any variable name: for ( int elephants = 0 ; elephants lt ; 1000 ; elephants = elephants + 1 ) { // this code will also run 1000 times! } The incrementing code, i = i + 1 is often abbreviated as i++ : for ( int i = 0 ; i lt ; 1000 ; i ++ ) { // this code will run 1000 times, too! } Finally, incrementation is not limited to increments of 1: // increments of 2 for ( int i = 0 ; i lt ; 1000 ; i = i + 2 ) { // this code will run 500 times } // increments of 5, abbreviated notation for ( int i = 0 ; i lt ; 1000 ; i += 5 ) { // this code will run 200 times! } Whew! That was quite a detour. Let's get back to our LED fade loop() function. We want our analogWrite() function to iterate up from 0 to 255 in increments of 5, so within our loop() function we can write: void loop () { for ( int lightLevel = 0 ; lightLevel lt ; = 255 ; lightLevel = lightLevel + 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } } Click \"Start Simulation\" and you'll see that we're halfway there. The LED starts OFF, fades to ON, and then jumps back to OFF again, fades to ON, jumps back to OFF, etc, etc. So we need a second for loop to decrement the light level (highlighted in yellow): void loop () { for ( int lightLevel = 0 ; lightLevel lt ; = 255 ; lightLevel = lightLevel + 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } for ( int lightLevel = 255 ; lightLevel gt ; = 0 ; lightLevel = lightLevel - 5 ) { analogWrite ( 0 , lightLevel ); delay ( 30 ); } } Click \"Start Simulation\" and the LED should slowly fade in and out, as if it were breathing. Congratulations! You've successfully completed the \"Programmatically Fade an LED\" project!","title":"Programmatically Fade an LED"},{"location":"circuits/attiny85/#programmatically-fade-an-led-with-a-potentiometer","text":"In this next project, we'll add a potentiometer to our circuit and use it to control the fade level of the LED. Here is the circuit schematic for your reference: First, delete all of the code in the Text interface of your Code panel. We will write new code for this project. Next, close the Code panel to access your Components bin and locate the Potentiometer . Drag it onto your Tinkercad canvas. Connect the outer terminals of the potentiometer to the positive (+) and negative (-) bus of your breadboard. The \"wiper\" terminal of the potentiometer should be connected to one of the three pins on the ATtiny85 that are capable of reading analog voltages. They are marked in red as pins A1, A2, and A3 on the pinout diagram. In the example below, we've connected the potentiometer's wiper to pin A3 of the ATtiny85 using a yellow wire. Note At this point you may be asking: Why didn't we connect the potentiometer wiper in series with the LED to directly control the LED's brightness? That's a great question! Indeed, you might even be wondering why we need the ATtiny85 to accomplish this project at all! In fact, if all we want to do is use a potentiometer to control the brightness of an LED, we don't need a microcontroller to do that! You could save yourself time and money and avoid having to touch code at all! The purpose of this project, however, is on the one hand purely pedagogical: to teach you how to use a microcontroller to read an analog voltage. A microcontroller can put that information to use in many different ways. In the last project of this tutorial we'll make use of that analog signal to create a circuit that would be quite a bit more difficult to accomplish without a microcontroller. Stay tuned! Now that we've wired up our potentiometer, let's turn to the Arduino code necessary to read its output. Open the Code panel and again, switch to the Text interface. Let's begin by initializing some variables. We need one to hold the value coming in from our potentiometer on pin A3: int pot_value = 0 ; And let's use a variable name to identify the pin that attaches to our LED. This is considered a good practice in case you ever need to modify the pin configuration on your hardware. Rather than having to hunt through your code for every reference to pin 0 , you can simply change it in the variable list at the top of your sketch. int pot_value = 0 ; int ledPin = 0 ; Let's do the same for the pin that attaches to our potentiometer: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; Now that we've declared our variables, we can use these in our setup() function to set these pins as OUTPUT and INPUT as needed: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; void setup () { pinMode ( ledPin , OUTPUT ); pinMode ( sensorPin , INPUT ); } We can now turn our attention to our program's loop() function. The first thing we want to do each program cycle is read the value coming in over the ADC at pin A3 from the potentiometer and assign it to our pot_value variable: void loop () { pot_value = analogRead ( sensorPin ); } The next thing we want to do is to use that value to set the analogWrite() value for the LED pin. Important! The ADC of pin A3 runs at 10 bits, which means that analogRead() is going to be giving readings between 0 and 1023. Our analogWrite() function can only take an 8 bit value, between 0 and 255. To reconcile this difference, we need to use Arduino's map() math function and then use that re-mapped value to drive our LED. In the code highlighted below, we first re-map the 10 bit pot_value to an 8 bit number and then pass that re-mapped value to analogWrite() . void loop () { pot_value = analogRead ( sensorPin ); pot_value = map ( pot_value , 0 , 1023 , 0 , 255 ); analogWrite ( ledPin , pot_value ); } Our full code should read as follows: int pot_value = 0 ; int ledPin = 0 ; int sensorPin = A3 ; void setup () { pinMode ( ledPin , OUTPUT ); pinMode ( sensorPin , INPUT ); } void loop () { pot_value = analogRead ( sensorPin ); pot_value = map ( pot_value , 0 , 1023 , 0 , 255 ); analogWrite ( ledPin , pot_value ); } Click on \"Start Simulation.\" Use your mouse to manipulate the potentiometer. When the indicator is closest to the pin you have connected to the positive (+) voltage, the LED should burn brightest. When the indicator is moved toward the pin that you have connected to ground (-), the LED should dim and then turn off completely. Congratulations! You've completed the \"Programmatically Fade an LED with a Potentiometer\" project. Challenge You can use this same hardware setup to build another classic Arduino project: Using a potentiometer to control the blink speed of an LED. All you need to change is the Arduino code. See if you can't figure out how to make it work on your own, using the digitalWrite() , delay() , and map() functions. Hint: Map the potentiometer values to milliseconds and use in the delay() function! Email your code to your professor!","title":"Programmatically Fade an LED with a Potentiometer"},{"location":"circuits/attiny85/#rgb-led-color-control-with-a-potentiometer","text":"For our final circuit in this tutorial, we'll introduce a new component - an RGB LED - and use the readings from a potentiometer to programmatically change its colors depending on where the potentiometer is positioned. To save time, we'll begin by duplicating the project we just completed above. Return to your Circuits Dashboard . Find the design you just completed and click on the cog in the upper right corner of the project's card, as illustrated below. From the drop-down that appears, choose \"Duplicate.\" Tinkercad should take you to a new project, automatically entitled \"Copy of [original project name]\". For this circuit, we'll use the following circuit diagram: Note Note that the ATtiny85 in its basic configuration only has two PWM pins, and to use the full range of an RGB LED you need to have three. While it is possible to circumvent this limitation with code to enable a 3rd PWM pin, the Tinkercad simulator is not capable of that degree of complexity. So for the purposes of this tutorial, we'll simply make by using the ATtiny85's two PWM pins (0 and 1) and then pin 2 as a digital pin to generate a more limited set of colors. Let's begin with the wiring of the RGB LED. Delete the red LED, its resistor, and all of its related jumper wires from your project. This should leave only the battery and the potentiometer wired to your ATtiny85. Locate in the Components bin the RGB LED component and drag it to your breadboard. Connect the \"common cathode\" (-) pin of the RGB LED to GND. Add three 47\u03a9 resistor to your canvas, connecting one each to the red, green, and blue pins of the RGB LED. Connect each resistor to a specific digital pin on the ATtiny85, as follows: Connect the blue pin's resistor to digital pin 1 . Connect the green pin's resistor to digital pin 0 . Connect the red pin's resistor to digital pin 2 . Your circuit should look something like this: Tip If the image above is confusing to you, remember how a breadboard works. Everything in a numbered row on one side of the ravine is connected together. Now we can turn our attention to the Arduino Code. An RGB LED works by mixing three different LEDs - one red, one green, one blue - in different ratios of intensity. Let's begin by declaring variables for each of our RGB LED's pins: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; And then let's initialize each of these pins as OUTPUTs in the setup() function: void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } Here is a table that outlines different color combinations for the Tinkercad simulator based on ratios of red, green, and blue: Color Red Green Blue Red 100% 0% 0% Green 0% 100% 0% Blue 0% 0% 100% Yellow 100% 100% 0% Orange 100% 25% 0% Purple 100% 0% 100% Magenta 100% 0% 30% Turquoise 0% 100% 100% The above values can be translated to code, using analogWrite() and converting the percentages to an 8-bit value. So the color orange can be achieved by the following: // orange = red 100%, green 20%, blue 0% analogWrite ( redPin , 255 ); analogWrite ( greenPin , 64 ); // 25% of 255 is approx. 64 analogWrite ( bluePin , 0 ); Since our redPin , pin 2 is not capable of PWM, we instead need to use digitalWrite() on that pin: // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); // 25% of 255 is approx. 64 analogWrite ( bluePin , 0 ); Put the code above in your loop() function and test it out. The full code is: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } void loop () { // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } The RGB LED should glow orange. One of the things you can do in Arduino is declare custom functions outside of your setup() and loop() functions and then call them in these main functions. For example, you could create a function below your loop() function for the color orange: void colorOrange (){ // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } Then you can call that function in your loop() : int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); } void loop (){ colorOrange (); } void colorOrange () { // orange = red 100%, green 20%, blue 0% digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 64 ); analogWrite ( bluePin , 0 ); } Go ahead and create additional custom functions for red, blue, green, yellow, and turquiose. Try to do this on your own, without consulting the code below. void colorRed () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 0 ); } void colorBlue () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 255 ); } void colorGreen () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 0 ); } void colorYellow () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 0 ); } void colorTurquoise () { digitalWrite ( redPin , LOW ); analogWrite ( greenPin , 255 ); analogWrite ( bluePin , 255 ); } void colorPurple () { digitalWrite ( redPin , HIGH ); analogWrite ( greenPin , 0 ); analogWrite ( bluePin , 255 ); } Then create a simple sketch that cycles through the colors for a duration of two seconds each. Replace your loop() function with the following: void loop () { colorRed (); delay ( 2000 ); colorBlue (); delay ( 2000 ); colorGreen (); delay ( 2000 ); colorYellow (); delay ( 2000 ); colorPurple (); delay ( 2000 ); colorTurquoise (); delay ( 2000 ); } Test out your code by clicking the \"Start Simulation\" button. Failure? If you used a different sequence of colors than the sequence above, you may have noticed that the simulator skips one or more of your colors. This is an error in the simulator, not your code. I have found that the simulator struggles to switch to orange in particular. Finally, we can now integrate the potentiometer back into our code and use it to select different colors. Note that the potentiometer has seven (7) dots around its perimeter, which have been marked with letters a-g in the image below left. These markings roughly correspond to the 10-bit potentiometer readings in the table at right: Marking pot_value color a 1023 red b 850 blue c 680 green d 510 yellow e 340 purple f 170 turquoise g 0 orange Since it is unlikely that anyone can consistently set the potentiometer to the exact position that generates those specific values, we can create a buffer of a range of values to segment our potentiometer into seven \"zones\": Marking ideal pot_value range color a 1023 940 - 1023 red b 850 770 - 940 blue c 680 599 - 769 green d 510 428 - 598 yellow e 340 257 - 427 purple f 170 86 - 256 turquoise g 0 0 - 85 orange Alternatively, and perhaps more straightforward, we can map the potentiometer values to a smaller range of values and then use the following to demarcate the potentiometer: Marking ideal pot_value range color a 18 17 - 18 red b 15 14 - 16 blue c 12 11 - 13 green d 9 8 - 10 yellow e 6 5 - 7 purple f 3 2 - 4 turquoise g 0 0 - 1 orange Let's make use of this information to control the RGB LED color with the potentiometer. Return to your project's code in the Code panel. Add the highlighted variables -- they should be familiar to you -- above your setup() function: int int redPin = 2 ; int greenPin = 0 ; int bluePin = 1 ; int sensorPin = A3 ; int pot_value = 0 ; void setup () ... Add the highlighted line to your setup() function: void setup () { pinMode ( redPin , OUTPUT ); pinMode ( greenPin , OUTPUT ); pinMode ( bluePin , OUTPUT ); pinMode ( sensorPin , INPUT ); } Finally, re-write your loop() function in this way: At the start of each program loop, set the value of pot_value to the reading from the potentiometer: void loop () { pot_value = analogRead ( sensorPin ); } Next, let's re-map the potentiometer value to a new int variable named val : void loop () { pot_value = analogRead ( sensorPin ); int val = map ( pot_value , 0 , 1023 , 0 , 18 ); } Then use a series of if statements to set the RGB LED to different colors based on the value of val depending on whether it falls within a specified range of values, as in the code below: void loop () { pot_value = analogRead ( sensorPin ); int val = map ( pot_value , 0 , 1023 , 0 , 18 ); if ( 0 lt ; = val amp ; amp ; val lt ; = 1 ) { colorOrange (); } if ( 2 lt ; = val amp ; amp ; val lt ; = 4 ) { colorTurquoise (); } if ( 5 lt ; = val amp ; amp ; val lt ; = 7 ) { colorPurple (); } if ( 8 lt ; = val amp ; amp ; val lt ; = 10 ) { colorYellow (); } if ( 11 lt ; = val amp ; amp ; val lt ; = 13 ) { colorGreen (); } if ( 14 lt ; = val amp ; amp ; val lt ; = 16 ) { colorBlue (); } if ( 17 lt ; = val amp ; amp ; val lt ; = 18 ) { colorRed (); } } Test your project by clicking \"Start Simulation\" and then click on the potentiometer to move it between different marks. Great job completing the last project in this tutorial! Begin brainstorming a circuit based on the ATtiny85 that you'd like to prototype and have manufactured... \"10-bit\" refers to the resolution of the ADC, meaning that it can convert an analog signal into 1024 (0-1023) discrete levels. See https://en.wikipedia.org/wiki/Analog-to-digital_converter#Resolution","title":"RGB LED Color Control with a Potentiometer"},{"location":"circuits/eagle/","text":"This tutorial offers a step-by-step introduction to creating a basic PCB (printed circuit board) for manufacture. Following on previous tutorials, the circuit makes use of the ATtiny85 microcontroller. Required Software This tutorial makes use of Autodesk Eagle and Autodesk Fusion . Assumptions Before embarking on this tutorial it is recommended that you complete the following Autodesk Eagle tutorials: Schematic Basics Part 1: Search, Place, Move Schematic Basics Part 2: Nets and Values Schematic Basics Part 3: ERC PCB Layout Basics Part 1: How to Place Your Components Routing Autorouting \u2013 PCB Layout Basics 2 Design Rule Check: PCB Layout Basics 3 Getting Started Resistors: rcl library","title":"Eagle"},{"location":"circuits/eagle/#required-software","text":"This tutorial makes use of Autodesk Eagle and Autodesk Fusion .","title":"Required Software"},{"location":"circuits/eagle/#assumptions","text":"Before embarking on this tutorial it is recommended that you complete the following Autodesk Eagle tutorials: Schematic Basics Part 1: Search, Place, Move Schematic Basics Part 2: Nets and Values Schematic Basics Part 3: ERC PCB Layout Basics Part 1: How to Place Your Components Routing Autorouting \u2013 PCB Layout Basics 2 Design Rule Check: PCB Layout Basics 3","title":"Assumptions"},{"location":"circuits/eagle/#getting-started","text":"Resistors: rcl library","title":"Getting Started"},{"location":"circuits/feather/","text":"This tutorial walks through the setup process for registering your Feather M0 on Duke's network and setting up your Arduino IDE to program the device. About the Feather M0 For the remainder of the semester we will be working with the Adafruit Feather M0 , a powerful Arduino-compatible microcontroller with integrated wifi. Adafruit hosts an excellent overview and setup guide for the Feather M0. Please consult it alongside this setup tutorial. Register on DukeReg Before we can use the Feather M0's wifi capabilities on Duke's network, we need to register its Mac address on DukeReg so that Duke's network will recognize it as an authorized device. First, locate your Feather M0's Mac address, located on the white sticker on the Feather's wifi chip (outlined in red in the image below): Next, open a web browser to https://dukereg.duke.edu/ . You will be prompted to enter your NetID and password. Click on the green button to \"Register a New Device.\" In the subsequent form, type the Mac address as it appears on your Feather. Give your device a name (\"Feather M0\") and choose \"Other\" for OS and \"Personal\" for Ownership. Click on the blue \"Register\" button. The page should refresh, indicating that the \"Device was successfully registered. Click on the \"Back\" button to return to your list of registered devices. Confirm that the Mac address you submitted matches the Mac address on your Feather M0. If it does not match, click the Delete button next to the mis-typed entry and then create a new registration. Duke's network may take up to 45 minutes to propagate this authorized registration to all its wifi endpoints. Configure the Arduino IDE In this next section, we'll configure the Arduino IDE to recognize the Feather M0 microcontroller. Launch the Arduino IDE program. Open up the Preferences pane. (On OS X, this is under the main menu: Arduino -- Preferences. On Windows, it is acccessible under File -- Preferences.) Be sure to check the box next to \"Display Line Numbers.\" Next, click on the icon to the far right of the \"Additional Boards Manager URLs\" textbox. A dialog box will pop up. In this box you will see any previous custom board definition URLs you may have entered (such as the ATtiny package from Github user damellis ): On a new line, enter the following URL: https://adafruit.github.io/arduino-board-index/package_adafruit_index.json and then click the \"OK\" button. Click the \"OK\" button in the Preferences pane to save your changes. Now we are ready to add the board definitions to Arduino so that we can program the Feather MO. Open the Boards Manager under the main menu: Tools -- Board -- Boards Manager: We will need to install two sets of board definitions. First, scroll down until you find \"Arduino SAMD Boards (32-bits ARM Cortex-M0+) by Arduino\". Click \"Install\" to download and install the latest version. Further down the list you should also fine \"Adafruit SAMD Boards by Adafruit.\" Click \"Install\" to download and install the latest version of this set of board definitions. Don't See the Adafruit SAMD option? If the Adafruit SAMD Boards option does not appear on your list of possible board definitions to install, you may have entered the URL incorrectly in step #5 above. Return to your Preferences pane to verify. Click the \"Close\" button to close the Boards Manager. Windows users only: Download and install the latest Adafruit Drivers Package . Restart the Arduino IDE application. Check to see that the \"Adafruit Feather M0\" appears as an option under Tools -- Board Blink Now that you've configured the Arduino IDE to recognize the Feather M0, let's test it with a simple Blink sketch. Use the USB cable to plug your Feather M0 into an available USB port on your computer. Open the default Blink sketch. From the main menu, choose File -- Examples -- 01.Basics -- Blink Make sure you have the Adafruit Feather M0 selected under Tools -- Board. Choose Tools -- Port and select the USB port for your board. Click the Upload button (or choose Sketch -- Upload) The onboard LED on the Feather M0 should blink on and off every second. Feather M0 as Webserver Next we'll make use of the WiFi101 library to enable the Feather M0's wifi chip and use it to serve up a webpage from the Feather itself that can be used to control the onboard LED. From the main menu, choose Sketch -- Include Library -- Manage Libraries. In the Library Manager dialog box that appears, type \"Wifi101\" in the Filter your search... text box. The WiFi101 library should appear at the top of the search results. Click the \"Install\" button to install the latest version of the library. Click the \"Close\" button to return to the main programming interface. From the main menu, choose File -- New to start a new sketch. We will make use of Tom Igoe's Nov 2012 SimpleWebServerWiFi sketch to create a simple web server that lets you blink an LED via the web. This sketch will print the IP address of your WiFi connection (once connected) to the Serial monitor. From there, you can open that address in a web browser to turn on and off the Feather's built-in LED (pin 13). If the IP address of your shield is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off Copy and paste the following code into your sketch, replacing what is there by default: #include SPI.h #include WiFi101.h char ssid [] = DukeOpen ; // your network SSID (name) // char pass[] = ; // not used with DukeOpen int status = WL_IDLE_STATUS ; WiFiServer server ( 80 ); int ledPin = 13 ; // specify built-in LED void setup () { Serial . begin ( 9600 ); // initialize serial communication pinMode ( ledPin , OUTPUT ); // set the LED pin mode //Configure pins specific to Adafruit ATWINC1500 Feather M0 WiFi . setPins ( 8 , 7 , 4 , 2 ); // check for the presence of WiFi: if ( WiFi . status () == WL_NO_SHIELD ) { Serial . println ( WiFi not present ); while ( true ); // don t continue } // attempt to connect to WiFi network: while ( status != WL_CONNECTED ) { Serial . print ( Attempting to connect to Network named: ); Serial . println ( ssid ); // print the network name (SSID); // Connect to open network. status = WiFi . begin ( ssid ); // if using password WEP, use the following instead //status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay ( 10000 ); } server . begin (); // start the web server on port 80 printWiFiStatus (); // you re connected now, so print out the status } void loop () { WiFiClient client = server . available (); // listen for incoming clients if ( client ) { // if you get a client, Serial . println ( new client ); // print a message out the serial port String currentLine = ; // make a String to hold incoming data from the client while ( client . connected ()) { // loop while the client s connected if ( client . available ()) { // if there s bytes to read from the client, char c = client . read (); // read a byte, then Serial . write ( c ); // print it out the serial monitor if ( c == \\n ) { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that s the end of the client HTTP request, so send a response: if ( currentLine . length () == 0 ) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what s coming, then a blank line: client . println ( HTTP/1.1 200 OK ); client . println ( Content-type:text/html ); client . println (); // the content of the HTTP response follows the header: client . print ( Click lt;a href= \\ /H \\ gt;here lt;/a gt; turn the LED on pin 13 on lt;br gt; ); client . print ( Click lt;a href= \\ /L \\ gt;here lt;/a gt; turn the LED on pin 13 off lt;br gt; ); // The HTTP response ends with another blank line: client . println (); // break out of the while loop: break ; } else { // if you got a newline, then clear currentLine: currentLine = ; } } else if ( c != \\r ) { // if you got anything else but a carriage return character, currentLine += c ; // add it to the end of the currentLine } // Check to see if the client request was GET /H or GET /L : if ( currentLine . endsWith ( GET /H )) { digitalWrite ( ledPin , HIGH ); // GET /H turns the LED on } if ( currentLine . endsWith ( GET /L )) { digitalWrite ( ledPin , LOW ); // GET /L turns the LED off } } } // close the connection: client . stop (); Serial . println ( client disonnected ); } } void printWiFiStatus () { // print the SSID of the network you re attached to: Serial . print ( SSID: ); Serial . println ( WiFi . SSID ()); // print your WiFi shield s IP address: IPAddress ip = WiFi . localIP (); Serial . print ( IP Address: ); Serial . println ( ip ); // print the received signal strength: long rssi = WiFi . RSSI (); Serial . print ( signal strength (RSSI): ); Serial . print ( rssi ); Serial . println ( dBm ); // print where to go in a browser: Serial . print ( To see this page in action, open a browser to http:// ); Serial . println ( ip ); }","title":"Feather M0"},{"location":"circuits/feather/#about-the-feather-m0","text":"For the remainder of the semester we will be working with the Adafruit Feather M0 , a powerful Arduino-compatible microcontroller with integrated wifi. Adafruit hosts an excellent overview and setup guide for the Feather M0. Please consult it alongside this setup tutorial.","title":"About the Feather M0"},{"location":"circuits/feather/#register-on-dukereg","text":"Before we can use the Feather M0's wifi capabilities on Duke's network, we need to register its Mac address on DukeReg so that Duke's network will recognize it as an authorized device. First, locate your Feather M0's Mac address, located on the white sticker on the Feather's wifi chip (outlined in red in the image below): Next, open a web browser to https://dukereg.duke.edu/ . You will be prompted to enter your NetID and password. Click on the green button to \"Register a New Device.\" In the subsequent form, type the Mac address as it appears on your Feather. Give your device a name (\"Feather M0\") and choose \"Other\" for OS and \"Personal\" for Ownership. Click on the blue \"Register\" button. The page should refresh, indicating that the \"Device was successfully registered. Click on the \"Back\" button to return to your list of registered devices. Confirm that the Mac address you submitted matches the Mac address on your Feather M0. If it does not match, click the Delete button next to the mis-typed entry and then create a new registration. Duke's network may take up to 45 minutes to propagate this authorized registration to all its wifi endpoints.","title":"Register on DukeReg"},{"location":"circuits/feather/#configure-the-arduino-ide","text":"In this next section, we'll configure the Arduino IDE to recognize the Feather M0 microcontroller. Launch the Arduino IDE program. Open up the Preferences pane. (On OS X, this is under the main menu: Arduino -- Preferences. On Windows, it is acccessible under File -- Preferences.) Be sure to check the box next to \"Display Line Numbers.\" Next, click on the icon to the far right of the \"Additional Boards Manager URLs\" textbox. A dialog box will pop up. In this box you will see any previous custom board definition URLs you may have entered (such as the ATtiny package from Github user damellis ): On a new line, enter the following URL: https://adafruit.github.io/arduino-board-index/package_adafruit_index.json and then click the \"OK\" button. Click the \"OK\" button in the Preferences pane to save your changes. Now we are ready to add the board definitions to Arduino so that we can program the Feather MO. Open the Boards Manager under the main menu: Tools -- Board -- Boards Manager: We will need to install two sets of board definitions. First, scroll down until you find \"Arduino SAMD Boards (32-bits ARM Cortex-M0+) by Arduino\". Click \"Install\" to download and install the latest version. Further down the list you should also fine \"Adafruit SAMD Boards by Adafruit.\" Click \"Install\" to download and install the latest version of this set of board definitions. Don't See the Adafruit SAMD option? If the Adafruit SAMD Boards option does not appear on your list of possible board definitions to install, you may have entered the URL incorrectly in step #5 above. Return to your Preferences pane to verify. Click the \"Close\" button to close the Boards Manager. Windows users only: Download and install the latest Adafruit Drivers Package . Restart the Arduino IDE application. Check to see that the \"Adafruit Feather M0\" appears as an option under Tools -- Board","title":"Configure the Arduino IDE"},{"location":"circuits/feather/#blink","text":"Now that you've configured the Arduino IDE to recognize the Feather M0, let's test it with a simple Blink sketch. Use the USB cable to plug your Feather M0 into an available USB port on your computer. Open the default Blink sketch. From the main menu, choose File -- Examples -- 01.Basics -- Blink Make sure you have the Adafruit Feather M0 selected under Tools -- Board. Choose Tools -- Port and select the USB port for your board. Click the Upload button (or choose Sketch -- Upload) The onboard LED on the Feather M0 should blink on and off every second.","title":"Blink"},{"location":"circuits/feather/#feather-m0-as-webserver","text":"Next we'll make use of the WiFi101 library to enable the Feather M0's wifi chip and use it to serve up a webpage from the Feather itself that can be used to control the onboard LED. From the main menu, choose Sketch -- Include Library -- Manage Libraries. In the Library Manager dialog box that appears, type \"Wifi101\" in the Filter your search... text box. The WiFi101 library should appear at the top of the search results. Click the \"Install\" button to install the latest version of the library. Click the \"Close\" button to return to the main programming interface. From the main menu, choose File -- New to start a new sketch. We will make use of Tom Igoe's Nov 2012 SimpleWebServerWiFi sketch to create a simple web server that lets you blink an LED via the web. This sketch will print the IP address of your WiFi connection (once connected) to the Serial monitor. From there, you can open that address in a web browser to turn on and off the Feather's built-in LED (pin 13). If the IP address of your shield is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off Copy and paste the following code into your sketch, replacing what is there by default: #include SPI.h #include WiFi101.h char ssid [] = DukeOpen ; // your network SSID (name) // char pass[] = ; // not used with DukeOpen int status = WL_IDLE_STATUS ; WiFiServer server ( 80 ); int ledPin = 13 ; // specify built-in LED void setup () { Serial . begin ( 9600 ); // initialize serial communication pinMode ( ledPin , OUTPUT ); // set the LED pin mode //Configure pins specific to Adafruit ATWINC1500 Feather M0 WiFi . setPins ( 8 , 7 , 4 , 2 ); // check for the presence of WiFi: if ( WiFi . status () == WL_NO_SHIELD ) { Serial . println ( WiFi not present ); while ( true ); // don t continue } // attempt to connect to WiFi network: while ( status != WL_CONNECTED ) { Serial . print ( Attempting to connect to Network named: ); Serial . println ( ssid ); // print the network name (SSID); // Connect to open network. status = WiFi . begin ( ssid ); // if using password WEP, use the following instead //status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay ( 10000 ); } server . begin (); // start the web server on port 80 printWiFiStatus (); // you re connected now, so print out the status } void loop () { WiFiClient client = server . available (); // listen for incoming clients if ( client ) { // if you get a client, Serial . println ( new client ); // print a message out the serial port String currentLine = ; // make a String to hold incoming data from the client while ( client . connected ()) { // loop while the client s connected if ( client . available ()) { // if there s bytes to read from the client, char c = client . read (); // read a byte, then Serial . write ( c ); // print it out the serial monitor if ( c == \\n ) { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that s the end of the client HTTP request, so send a response: if ( currentLine . length () == 0 ) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what s coming, then a blank line: client . println ( HTTP/1.1 200 OK ); client . println ( Content-type:text/html ); client . println (); // the content of the HTTP response follows the header: client . print ( Click lt;a href= \\ /H \\ gt;here lt;/a gt; turn the LED on pin 13 on lt;br gt; ); client . print ( Click lt;a href= \\ /L \\ gt;here lt;/a gt; turn the LED on pin 13 off lt;br gt; ); // The HTTP response ends with another blank line: client . println (); // break out of the while loop: break ; } else { // if you got a newline, then clear currentLine: currentLine = ; } } else if ( c != \\r ) { // if you got anything else but a carriage return character, currentLine += c ; // add it to the end of the currentLine } // Check to see if the client request was GET /H or GET /L : if ( currentLine . endsWith ( GET /H )) { digitalWrite ( ledPin , HIGH ); // GET /H turns the LED on } if ( currentLine . endsWith ( GET /L )) { digitalWrite ( ledPin , LOW ); // GET /L turns the LED off } } } // close the connection: client . stop (); Serial . println ( client disonnected ); } } void printWiFiStatus () { // print the SSID of the network you re attached to: Serial . print ( SSID: ); Serial . println ( WiFi . SSID ()); // print your WiFi shield s IP address: IPAddress ip = WiFi . localIP (); Serial . print ( IP Address: ); Serial . println ( ip ); // print the received signal strength: long rssi = WiFi . RSSI (); Serial . print ( signal strength (RSSI): ); Serial . print ( rssi ); Serial . println ( dBm ); // print where to go in a browser: Serial . print ( To see this page in action, open a browser to http:// ); Serial . println ( ip ); }","title":"Feather M0 as Webserver"},{"location":"circuits/tinkercad/","text":"Assumptions The following tutorial assumes that: You have created a Tinkercad / Autodesk account. (If you have not yet done so, please create one .) You are signed in using your account. You have already completed the four tutorials in the Circuits \u201cGetting Started\u201d Project Gallery : Start Simulating Editing Components (we\u2019ll cover Arduino in a future class; this just shows you how to modify components whose properties are editable.) Wiring Components Adding Components You have already completed the three Circuits \u201cSkill Builders Lessons\u201d : Introducing the Breadboard Ohm\u2019s Law Series and Parallel Circuits Circuit Setup In this section of the tutorial you will create two identical circuits in the same Tinkercad Circuits workspace: one without a breadboard, and the second using a breadboard. Later in the tutorial we will use these circuits to gain a better understanding of current, resistance, and voltage. In both cases, you will be creating a simple LED circuit using a battery, LED, and resistor. Here is the circuit diagram: Calculate the Proper Resistor Value: The circuit diagram above indicates a 3V battery (2 x AA) and an LED with a forward voltage (voltage drop) of approximately 2.06V. The LED's ideal forward current is 20mA. What is the ideal resistor value (in ohms) for this circuit? In other words, what resistor (R) will keep the current (I) through the LED closest to 20mA, the current at which the LED will burn the brightest without jeopardizing its longevity or, worse, overloading? Use this formula (based on Ohm's Law and Kirchhoff\u2019s voltage law): R = \\frac{V_{source}-V_{drop}}{I_{forward}} R = \\frac{V_{source}-V_{drop}}{I_{forward}} Answer: $$ R\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ \\Omega $$ Circuit #1 - No Breadboard LED Circuit Go to your Tinkercad Dashboard https://www.tinkercad.com/#/dashboard Click on the Circuits button in the left panel. Click on the green \"Create new Circuit\" button. Create new Circuit A new blank canvas will open in your browser. Using the Components Palette on the right, click and drag the following components into the canvas: Resistor LED 1.5V Battery (AA) Click on the Battery in the canvas. In the configuration panel that appears, set the \"Count\" to \"2 Batteries\" (e.g. we want a 3V supplied to our circuit, so 2 x 1.5V = 3V ). Click on the Resistor in the canvas. In the configuration panel that appears, set the Resistance to the \u03a9 you calculated above. Click and drag between terminals of your components to wire up your circuit. If you wish, you may click on the individual wires to set their color. After completing your wiring and arranging/rotating the components, your circuit should look something like this: Click on the \"Start Simulation\" button in the upper-right of the browser window to simulate the circuit. The LED should be brightly lit. Troubleshooting If your LED is blown or shows a warning indicator, your calculated resistor value is too low. Review your calculations. If your LED is dim, your calculated resistor value is too high. Review your calculations. If your LED does not turn on at all, you may have mis-wired your circuit. Check your connections and wire-routing. Remember, LEDs are diodes and thus have polarity. Circuit #2 - LED Circuit on a Breadboard Next, using the same canvas, let's create a breadboard version of the same circuit. Move the circuit you just created to the left or right of the canvas to give yourself space for the new circuit. Again, using the Components Palette on the right, click and drag the following components into the canvas: Resistor LED 1.5V Battery (AA) Breadboard Set the Battery Count to 2. Set the Resistor's resistance to the same \u03a9 value you calculated for the non-breadboard circuit above. Using wires and the breadboard, create the circuit. Hint Hovering your mouse over the breadboard rows will remind you how a breadboard is configured (power buses on the outside rails, connected rows separated by a \"ravine\"). After completing your wiring and arranging/rotating the components, your circuit should look something like this: Click on the \"Start Simulation\" button again in the upper-right of the browser window to simulate the circuit. The LED on the breadboard should be brightly lit. Using a Multimeter Now that we have a working circuit, let's use Tinkercad's virtual multimeter to take some measurements on our circuit. From the Components Palette, find the Multimeter and add it to your canvas. Note that the multimeter has three modes. By default, it will function in Voltage mode as a voltmeter , enabling you to read voltages across different points in your circuit. The multimeter can be set to other modes easily by clicking on the multimeter in your canvas to display the configuration panel and selecting a different mode. In Amperage mode, it will function as an ammeter , enabling you to read the current passing through specific points in your circuit. In Resistance mode, it will function as an ohmmeter , enabling you to read the resistance between specific points in your circuit. Reading Voltages We know that the total voltage of our circuit is 3V because the voltage differential between the cathode (+ terminal) and anode (- terminal) of the battery is 3V (assuming it is fully charged). But let's read voltages between various points in the circuit. Read the voltage between the two sides of the resistor: Voltage Across the Resistor Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Read the voltage between the anode and the cathode of the LED: Voltage Across the LED Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Finally, read the voltage between the two terminals of the battery in the circuit. Voltage Across the Battery Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ If your voltage reading \u2260 3V, what do you think accounts for the difference? What do you observe when you add the voltage across the resistor to the voltage across the LED? Total Voltage Fill in your reading below: $$ V_{resistor} + V_{led} \\ = \\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Observation: Reading Amperage Finally, let's use the multimeter as an ammeter to measure the total current (I) being drawn by our circuit. Important Remember: Voltmeter and ohmmeters are wired in parallel to the component being measured. However, ammeters must be wired in series . See https://learn.sparkfun.com/tutorials/series-and-parallel-circuits Wire your multimeter into your circuit in series as illustrated below: Measuring Current What is the current being drawn by the circuit? Provide your answer in both amps (A) and milliamps (mA) What happens to the current if you increase the voltage in the circuit, such as changing the battery from two AA's (3V) to 3 AA's (4.5V)? Similarly, what happens if you leave the voltage alone but increase the resistance in the circuit, such as increasing the resistance of the resistor to 100 \u03a9?","title":"Tinkercad"},{"location":"circuits/tinkercad/#assumptions","text":"The following tutorial assumes that: You have created a Tinkercad / Autodesk account. (If you have not yet done so, please create one .) You are signed in using your account. You have already completed the four tutorials in the Circuits \u201cGetting Started\u201d Project Gallery : Start Simulating Editing Components (we\u2019ll cover Arduino in a future class; this just shows you how to modify components whose properties are editable.) Wiring Components Adding Components You have already completed the three Circuits \u201cSkill Builders Lessons\u201d : Introducing the Breadboard Ohm\u2019s Law Series and Parallel Circuits","title":"Assumptions"},{"location":"circuits/tinkercad/#circuit-setup","text":"In this section of the tutorial you will create two identical circuits in the same Tinkercad Circuits workspace: one without a breadboard, and the second using a breadboard. Later in the tutorial we will use these circuits to gain a better understanding of current, resistance, and voltage. In both cases, you will be creating a simple LED circuit using a battery, LED, and resistor. Here is the circuit diagram: Calculate the Proper Resistor Value: The circuit diagram above indicates a 3V battery (2 x AA) and an LED with a forward voltage (voltage drop) of approximately 2.06V. The LED's ideal forward current is 20mA. What is the ideal resistor value (in ohms) for this circuit? In other words, what resistor (R) will keep the current (I) through the LED closest to 20mA, the current at which the LED will burn the brightest without jeopardizing its longevity or, worse, overloading? Use this formula (based on Ohm's Law and Kirchhoff\u2019s voltage law): R = \\frac{V_{source}-V_{drop}}{I_{forward}} R = \\frac{V_{source}-V_{drop}}{I_{forward}} Answer: $$ R\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ \\Omega $$","title":"Circuit Setup"},{"location":"circuits/tinkercad/#circuit-1-no-breadboard-led-circuit","text":"Go to your Tinkercad Dashboard https://www.tinkercad.com/#/dashboard Click on the Circuits button in the left panel. Click on the green \"Create new Circuit\" button. Create new Circuit A new blank canvas will open in your browser. Using the Components Palette on the right, click and drag the following components into the canvas: Resistor LED 1.5V Battery (AA) Click on the Battery in the canvas. In the configuration panel that appears, set the \"Count\" to \"2 Batteries\" (e.g. we want a 3V supplied to our circuit, so 2 x 1.5V = 3V ). Click on the Resistor in the canvas. In the configuration panel that appears, set the Resistance to the \u03a9 you calculated above. Click and drag between terminals of your components to wire up your circuit. If you wish, you may click on the individual wires to set their color. After completing your wiring and arranging/rotating the components, your circuit should look something like this: Click on the \"Start Simulation\" button in the upper-right of the browser window to simulate the circuit. The LED should be brightly lit. Troubleshooting If your LED is blown or shows a warning indicator, your calculated resistor value is too low. Review your calculations. If your LED is dim, your calculated resistor value is too high. Review your calculations. If your LED does not turn on at all, you may have mis-wired your circuit. Check your connections and wire-routing. Remember, LEDs are diodes and thus have polarity.","title":"Circuit #1 - No Breadboard LED Circuit"},{"location":"circuits/tinkercad/#circuit-2-led-circuit-on-a-breadboard","text":"Next, using the same canvas, let's create a breadboard version of the same circuit. Move the circuit you just created to the left or right of the canvas to give yourself space for the new circuit. Again, using the Components Palette on the right, click and drag the following components into the canvas: Resistor LED 1.5V Battery (AA) Breadboard Set the Battery Count to 2. Set the Resistor's resistance to the same \u03a9 value you calculated for the non-breadboard circuit above. Using wires and the breadboard, create the circuit. Hint Hovering your mouse over the breadboard rows will remind you how a breadboard is configured (power buses on the outside rails, connected rows separated by a \"ravine\"). After completing your wiring and arranging/rotating the components, your circuit should look something like this: Click on the \"Start Simulation\" button again in the upper-right of the browser window to simulate the circuit. The LED on the breadboard should be brightly lit.","title":"Circuit #2 - LED Circuit on a Breadboard"},{"location":"circuits/tinkercad/#using-a-multimeter","text":"Now that we have a working circuit, let's use Tinkercad's virtual multimeter to take some measurements on our circuit. From the Components Palette, find the Multimeter and add it to your canvas. Note that the multimeter has three modes. By default, it will function in Voltage mode as a voltmeter , enabling you to read voltages across different points in your circuit. The multimeter can be set to other modes easily by clicking on the multimeter in your canvas to display the configuration panel and selecting a different mode. In Amperage mode, it will function as an ammeter , enabling you to read the current passing through specific points in your circuit. In Resistance mode, it will function as an ohmmeter , enabling you to read the resistance between specific points in your circuit.","title":"Using a Multimeter"},{"location":"circuits/tinkercad/#reading-voltages","text":"We know that the total voltage of our circuit is 3V because the voltage differential between the cathode (+ terminal) and anode (- terminal) of the battery is 3V (assuming it is fully charged). But let's read voltages between various points in the circuit. Read the voltage between the two sides of the resistor: Voltage Across the Resistor Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Read the voltage between the anode and the cathode of the LED: Voltage Across the LED Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Finally, read the voltage between the two terminals of the battery in the circuit. Voltage Across the Battery Fill in your reading below: $$ Voltage\\ =\\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ If your voltage reading \u2260 3V, what do you think accounts for the difference? What do you observe when you add the voltage across the resistor to the voltage across the LED? Total Voltage Fill in your reading below: $$ V_{resistor} + V_{led} \\ = \\ \\Rule{1cm}{0.15mm}{0.15mm} \\ V $$ Observation:","title":"Reading Voltages"},{"location":"circuits/tinkercad/#reading-amperage","text":"Finally, let's use the multimeter as an ammeter to measure the total current (I) being drawn by our circuit. Important Remember: Voltmeter and ohmmeters are wired in parallel to the component being measured. However, ammeters must be wired in series . See https://learn.sparkfun.com/tutorials/series-and-parallel-circuits Wire your multimeter into your circuit in series as illustrated below: Measuring Current What is the current being drawn by the circuit? Provide your answer in both amps (A) and milliamps (mA) What happens to the current if you increase the voltage in the circuit, such as changing the battery from two AA's (3V) to 3 AA's (4.5V)? Similarly, what happens if you leave the voltage alone but increase the resistance in the circuit, such as increasing the resistance of the resistor to 100 \u03a9?","title":"Reading Amperage"}]}